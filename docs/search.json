[
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "To participate in this course you will need access to Python and an up-to-date web browser. You will also need a range of Python libraries from the standard scientific stack: Jupyter, Numpy, Scipy and Matplotlib.\nAll of the software needed for this course is pre-installed in the MPEE computers at Northumbria University. However we highly recommend you install Python on your own laptop or computer so that you can work from home, or from a cafe - wherever you work best! To install Python and the scientific libraries on your personal laptop or desktop carefully follow the instructions listed below.\nYou can also run the Python Jupyter Notebook files remotely through the binder or colab services whenever you see the icon for these services. But be warned! Any changes you make are not saved and the service can time-out after a period of inactivity (usually ~20 minutes). This service should be used as a if-nothing-else-works plan only.\nYou will also need a user account at github.com - Basic GitHub accounts are free.\n\nPython\nPython is a popular language for scientific computing, and great for general-purpose programming as well. Installing all of its scientific packages individually can be a bit difficult, however, so we recommend the all-in-one installer Anaconda.\n\nWindows - video tutorial\n\nOpen this link with your web browser.\nDownload the Anaconda for Windows installer with Python 3. (If you are not sure which version to choose, you probably want the 64-bit Graphical Installer Anaconda3-…-Windows-x86_64.exe)\nDouble-click the executable and install Python 3 using MOST of the default settings, the only exception is to check Add Anaconda to my PATH environment variable.\n\n\n\nMac OS X - video tutorial\n\nOpen this link with your web browser.\nDownload the Anaconda Installer with Python 3 for macOS (you can either use the Graphical or the Command Line Installer).\nInstall Python 3 by running the Anaconda Installer using all of the defaults for installation.\n\n\n\n\nA browser for Jupyter\nWe will teach Python using the [Jupyter notebook][https://jupyter.org/], a programming environment that runs in a web browser. Jupyter requires a reasonably up-to-date browser, preferably a current version of Chrome, Safari, or Firefox (note that Internet Explorer version 9 and below are not supported). Jupyter is installed as part of the Anaconda package for Python.\n\n\nHow to launch a Jupyter Notebook\n\nSearch for “Anaconda” using your system search bar\nSelect “Anaconda Launcher”\nClick on the “Launch” button below “Jupyter Notebook”. You should see a file browser pop up as a new tab on your browser.\nClick new towards the top right hand side of the browser window.\nSelect Python 3 in the drop-down menu bar. This will open a Python 3 Notebook file a new tab in your browser."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website contains resources for the second year course “Theory, computation and experiment” (KD5081) at Northumbria University, UK. The resources have been developed by Dr Lucy Whalley. If you spot any mistakes or have any suggestions please raise an issue on the Github repository for this course.\nThe website is powered by Github and fastpages, which is licensed under Apache License 2.0.\nThe content of this website is adapted and derived from several other sources:\n\nThe Setup instructions page is a derivative of materials from Software Carpentry, used under Attribution 4.0 International (CC BY 4.0).\nThe tutorial “Testing and Documentation” is a derivative of the Testing lesson from Code Refinery, used under Attribution 4.0 International (CC BY 4.0).\nSome of the exercises are adapted from the book Computational Physics. These are used with the permission of the book’s author, Mark Newman, and remain under his copyright.\n\nIn addition, parts of the “Getting results” section were inspired by Rudolf Winter’s notes on ODEs and PDEs.\nThe content of this website unless otherwise indicated is licensed under Creative Commons Attribution 4.0 International. You can re-use any of its content as long as an attribution is included, and you indicate if changes were made."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Physics",
    "section": "",
    "text": "Computing has become central to virtually all research and development in academia and industry, and with the advent of Machine Learning and High-Performance Computing this dominance is set to continue.\nComputational physics encompasses a wide number of areas including materials modelling, particle physics simulations, protein structure prediction and plasma modelling. In fact, it is possible to find a computational branch for every major field in physics.\nThe focus of this course is to equip with you with knowledge and skills needed to model a range of physical systems using numerical methods. You will also gain a number of transferable skills which can be applied across in a range of computational disciplines.\nThis course is split into three sections - Getting started, Getting results and Getting it out there. In the first part of the course, Getting started, we will recap the basic programming concepts and Python libraries that are applicable to a wide range of research and industry. In the middle section of the course, which is called Getting results, we will combine our Python knowledge with mathematical numerical methods to model various physical systems using differential equations. In the final unassessed section of the course, Getting it out there, we will use modern software engineering techniques to document, test and share our code.\n\nHow does this course relate to experimental physics?\nThe first part of this course recaps the basic skills needed for processing experimental data using Python. At the end of Getting started you will be able to read in experimental data from a plain text file, clean the data, apply basic statistical analysis and plot. We very much encourage you to apply the tools outlined in this course to your experimental analysis.\n\n\nDo I need to attend the in-person labs?\nWe will aim to publish all course materials on this website however a large component of this course is based on the verbal explanations whilst writing code (a.k.a, “live coding”) and class discussion. It will all make much more sense if you attend the sessions in the computer lab. The computer labs will not be recorded.\n\n\nWhy do you use a website?\nBlackboard collaborate is widely used at Northumbria University for teaching. However in the computational sciences (and in software engineering) Blackboard collaborate is not widely used. The aim here is to teach and learn using the tools that are already used in research and industry - hence building the course resources around the Github service. Also, the code can be nicely formatted using Markdown/html (rather than blackboard), making it easier for students to read and understand.\nThe source code for this website can be found in the course Github repository. If you spot any mistakes or would like to make a suggestions for improving the course please raise an issue on Github.\nBlackboard collaborate will be used for posting assessments and for course announcements."
  },
  {
    "objectID": "tutorials/integration.html",
    "href": "tutorials/integration.html",
    "title": "Riemann sums",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I do basic numerical integration?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nUse the rectangular-slice approximation to calculate integrals\nDescribe the difference between a zeroth-order and first-order integration rule\n\n\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nThe integral of \\(f(x)\\) from \\(a\\) to \\(b\\) is the area under the curve. Depending on the functional form of \\(f(x)\\), it may not be possible to calculate the integral analytically.\n\n\n\n\n\nRiemann sums are a family of methods used for approximating integrals\nThe Riemann definition of the integral \\(I\\) is:\n\\[ I = \\lim_{n\\to\\infty} \\sum_{i=1}^N h f(x_i)\\]\nwhere the domain of integration has been split into \\(N\\) slices, each with width \\(h = \\frac{b-a}{N}\\). As we cannot in practice consider an infinite number of slices, this definition will give an approximation to the exact answer. By making \\(N\\) large are approximation will, in many cases, be reasonable.\n\n\nThe simplest Riemann sum is based on rectangular slices\nThe simplest way to use this approach is to calculate \\(f(x_i)\\) at some point on each slice and then calculate the area of the associated rectangle:\n\\[ A_i = hf(x_i)\\]\nThe integral is given by summing over all of the rectangles:\n\\[ \\int_a^b f(x_i) dx \\approx \\sum_{i=1}^N A_i \\]\n\n\n\n\n\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nFor example, we may want to calculate the integral of \\(\\sin(x)\\) from 0 to \\(\\frac{\\pi}{2}\\). This is an integral that can be evaluated analytically, so it doesn’t usually make sense to calculate numerically - however, in this case, we can use it to establish that our method is correct.\n\nimport math\n\ndef sin(x):\n    \n    return math.sin(x)\n\ndef rectangular_slice_integral(f_x, a, b, N):\n    \n    integral = 0\n    h = (b-a) / N   # h is the width of each slice\n    for i in range(N):\n        x = a + h*i # the x value for the slice\n        integral += f_x(x)*h\n    return integral\n\nNote that the function rectangular_slice_integral has an argument f_x which is itself a function. This is valid Python - you can pass one function to another function as an argument.\n\nrectangular_slice_integral(sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nIn fact, it is possible to pass the math.sin() function directly to rectangular_slice_integral():\n\nrectangular_slice_integral(math.sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nThis is pretty close to the correct value of 1. To improve our approximation we can increase the number of slices:\n\nrectangular_slice_integral(math.sin,0,math.pi/2,200)\n\n0.9960678687587687\n\n\n The Riemann sums method a zeroth-order integration rule that will integrate a zeroth-order polynomial (ie, constant number) exactly. It has an error of order \\(h\\) (\\(\\mathcal{O}(h)\\)) - when we halve the rectangular width, we halve the error. \n\n\nRiemann sums can be adapted for use with discrete data\nNot all integrations are integrations of functions. For example, we may want to integrate experimental data, in which case there is no function to call to find the value of f(x). Instead, the most likely form of f(x) is given by the list of data values. In this case we can use the same method, but the implementation is slightly different:\n\ndef rectangular_slice_integral_discrete(data, h):\n    \n    return h*sum(data)\n\n Note that this assumes the data is evenly spaced at width \\(h\\) .\nTo test our function using the same example as above we need to generate a list of sin(x) values between 0 to \\(\\frac{\\pi}{2}\\):\n\nimport numpy as np\n\nh = (math.pi/2)/100\nsin_0_90 = [math.sin(x) for x in np.arange(0,math.pi/2,h)]\n\nwhere we are using Python list comprehension and the Numpy arange function to generate a list of evenly spaced floats.\nIf we are simulating experimental data we should add a little noise or randomness to the data. We can use the Python standard library random and list comprehension to do this:\n\nimport random\n\nsin_0_90_noise = [x+random.uniform(-0.1,0.1) for x in sin_0_90]\n\nWe can now pass this list to our function rectangular_slice_integral_discrete:\n\nrectangular_slice_integral_discrete(sin_0_90_noise, h)\n\n1.0094729791206596\n\n\nWe can visualise the exact sinusoidal curve and noisy sinusoidal curve using the matplotlib plotting library:\n\nimport matplotlib.pyplot as plt\n\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90,label=\"exact sine\")\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90_noise,label=\"noisy sine\")\n\n\n\n\n\n\nHigher-order Riemann sums increase the accuracy of our approximations\nWe can greatly improve the efficiency of our integration by approximating the slices as trapezoids instead of as rectangles. This is because the area under the trapezoids is a considerably better approximation to the area under the curve.\n The trapezoidal rule a first-order integration rule that will integrate a first-order polynomial (ie, a straight line) exactly. We can say it is accurate to order \\(h\\) (\\(\\mathcal{O}(h)\\)) and has an error of order \\(h^2\\) \\(\\mathcal{O}(h^2)\\) .\n\n\n\nIn many cases we can use Simpson’s Rule for greater accuracy still. This technique involves fitting quadratic curves to pairs of slices and then calculating the area under the quadratics. In many cases Simpson’s rule is more accurate than the trapezoidal rule, but this is not guaranteed for all integrands.\n\n\n\n\n\n\nKeypoints\n\n\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nRiemann sums are a family of methods used for approximating integral\nThe simplest Riemann sum is based on rectangular slices\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nRiemann sums can be adapted for use with discrete data\nHigher-order Riemann sums increase the accuracy of our approximations\n\n\n\n\n\n\n\n\n\nTest your understanding\n\n\n\n\nQuick test questions\nExtended questions"
  },
  {
    "objectID": "notebooks/integration.html",
    "href": "notebooks/integration.html",
    "title": "Riemann sums",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I do basic numerical integration?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nUse the rectangular-slice approximation to calculate integrals\nDescribe the difference between a zeroth-order and first-order integration rule\n\n\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nThe integral of \\(f(x)\\) from \\(a\\) to \\(b\\) is the area under the curve. Depending on the functional form of \\(f(x)\\), it may not be possible to calculate the integral analytically.\n\n\n\n\n\nRiemann sums are a family of methods used for approximating integrals\nThe Riemann definition of the integral \\(I\\) is:\n\\[ I = \\lim_{n\\to\\infty} \\sum_{i=1}^N h f(x_i)\\]\nwhere the domain of integration has been split into \\(N\\) slices, each with width \\(h = \\frac{b-a}{N}\\). As we cannot in practice consider an infinite number of slices, this definition will give an approximation to the exact answer. By making \\(N\\) large are approximation will, in many cases, be reasonable.\n\n\nThe simplest Riemann sum is based on rectangular slices\nThe simplest way to use this approach is to calculate \\(f(x_i)\\) at some point on each slice and then calculate the area of the associated rectangle:\n\\[ A_i = hf(x_i)\\]\nThe integral is given by summing over all of the rectangles:\n\\[ \\int_a^b f(x_i) dx \\approx \\sum_{i=1}^N A_i \\]\n\n\n\n\n\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nFor example, we may want to calculate the integral of \\(\\sin(x)\\) from 0 to \\(\\frac{\\pi}{2}\\). This is an integral that can be evaluated analytically, so it doesn’t usually make sense to calculate numerically - however, in this case, we can use it to establish that our method is correct.\n\nimport math\n\ndef sin(x):\n    \n    return math.sin(x)\n\ndef rectangular_slice_integral(f_x, a, b, N):\n    \n    integral = 0\n    h = (b-a) / N   # h is the width of each slice\n    for i in range(N):\n        x = a + h*i # the x value for the slice\n        integral += f_x(x)*h\n    return integral\n\nNote that the function rectangular_slice_integral has an argument f_x which is itself a function. This is valid Python - you can pass one function to another function as an argument.\n\nrectangular_slice_integral(sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nIn fact, it is possible to pass the math.sin() function directly to rectangular_slice_integral():\n\nrectangular_slice_integral(math.sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nThis is pretty close to the correct value of 1. To improve our approximation we can increase the number of slices:\n\nrectangular_slice_integral(math.sin,0,math.pi/2,200)\n\n0.9960678687587687\n\n\n The Riemann sums method a zeroth-order integration rule that will integrate a zeroth-order polynomial (ie, constant number) exactly. It has an error of order \\(h\\) (\\(\\mathcal{O}(h)\\)) - when we halve the rectangular width, we halve the error. \n\n\nRiemann sums can be adapted for use with discrete data\nNot all integrations are integrations of functions. For example, we may want to integrate experimental data, in which case there is no function to call to find the value of f(x). Instead, the most likely form of f(x) is given by the list of data values. In this case we can use the same method, but the implementation is slightly different:\n\ndef rectangular_slice_integral_discrete(data, h):\n    \n    return h*sum(data)\n\n Note that this assumes the data is evenly spaced at width \\(h\\) .\nTo test our function using the same example as above we need to generate a list of sin(x) values between 0 to \\(\\frac{\\pi}{2}\\):\n\nimport numpy as np\n\nh = (math.pi/2)/100\nsin_0_90 = [math.sin(x) for x in np.arange(0,math.pi/2,h)]\n\nwhere we are using Python list comprehension and the Numpy arange function to generate a list of evenly spaced floats.\nIf we are simulating experimental data we should add a little noise or randomness to the data. We can use the Python standard library random and list comprehension to do this:\n\nimport random\n\nsin_0_90_noise = [x+random.uniform(-0.1,0.1) for x in sin_0_90]\n\nWe can now pass this list to our function rectangular_slice_integral_discrete:\n\nrectangular_slice_integral_discrete(sin_0_90_noise, h)\n\n1.0094729791206596\n\n\nWe can visualise the exact sinusoidal curve and noisy sinusoidal curve using the matplotlib plotting library:\n\nimport matplotlib.pyplot as plt\n\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90,label=\"exact sine\")\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90_noise,label=\"noisy sine\")\n\n\n\n\n\n\nHigher-order Riemann sums increase the accuracy of our approximations\nWe can greatly improve the efficiency of our integration by approximating the slices as trapezoids instead of as rectangles. This is because the area under the trapezoids is a considerably better approximation to the area under the curve.\n The trapezoidal rule a first-order integration rule that will integrate a first-order polynomial (ie, a straight line) exactly. We can say it is accurate to order \\(h\\) (\\(\\mathcal{O}(h)\\)) and has an error of order \\(h^2\\) \\(\\mathcal{O}(h^2)\\) .\n\n\n\nIn many cases we can use Simpson’s Rule for greater accuracy still. This technique involves fitting quadratic curves to pairs of slices and then calculating the area under the quadratics. In many cases Simpson’s rule is more accurate than the trapezoidal rule, but this is not guaranteed for all integrands.\n\n\n\n\n\n\nKeypoints\n\n\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nRiemann sums are a family of methods used for approximating integral\nThe simplest Riemann sum is based on rectangular slices\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nRiemann sums can be adapted for use with discrete data\nHigher-order Riemann sums increase the accuracy of our approximations\n\n\n\n\n\n\n\n\n\nTest your understanding\n\n\n\n\nQuick test questions\nExtended questions"
  }
]