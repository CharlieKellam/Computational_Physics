[
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "To participate in this course you will need access to Python and an up-to-date web browser. You will also need a range of Python libraries from the standard scientific stack: Jupyter, Numpy, Scipy and Matplotlib.\nAll of the software needed for this course is pre-installed in the MPEE computers at Northumbria University. However we highly recommend you install Python on your own laptop or computer so that you can work from home, or from a cafe - wherever you work best! To install Python and the scientific libraries on your personal laptop or desktop carefully follow the instructions listed below.\nYou can also run the Python Jupyter Notebook files remotely through the binder or colab services whenever you see the icon for these services. But be warned! Any changes you make are not saved and the service can time-out after a period of inactivity (usually ~20 minutes). This service should be used as a if-nothing-else-works plan only.\nYou will also need a user account at github.com - Basic GitHub accounts are free.\n\nPython\nPython is a popular language for scientific computing, and great for general-purpose programming as well. Installing all of its scientific packages individually can be a bit difficult, however, so we recommend the all-in-one installer Anaconda.\n\nWindows - video tutorial\n\nOpen this link with your web browser.\nDownload the Anaconda for Windows installer with Python 3. (If you are not sure which version to choose, you probably want the 64-bit Graphical Installer Anaconda3-…-Windows-x86_64.exe)\nDouble-click the executable and install Python 3 using MOST of the default settings, the only exception is to check Add Anaconda to my PATH environment variable.\n\n\n\nMac OS X - video tutorial\n\nOpen this link with your web browser.\nDownload the Anaconda Installer with Python 3 for macOS (you can either use the Graphical or the Command Line Installer).\nInstall Python 3 by running the Anaconda Installer using all of the defaults for installation.\n\n\n\n\nA browser for Jupyter\nWe will teach Python using the [Jupyter notebook][https://jupyter.org/], a programming environment that runs in a web browser. Jupyter requires a reasonably up-to-date browser, preferably a current version of Chrome, Safari, or Firefox (note that Internet Explorer version 9 and below are not supported). Jupyter is installed as part of the Anaconda package for Python.\n\n\nHow to launch a Jupyter Notebook\n\nSearch for “Anaconda” using your system search bar\nSelect “Anaconda Launcher”\nClick on the “Launch” button below “Jupyter Notebook”. You should see a file browser pop up as a new tab on your browser.\nClick new towards the top right hand side of the browser window.\nSelect Python 3 in the drop-down menu bar. This will open a Python 3 Notebook file a new tab in your browser."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website contains resources for the second year course “Theory, computation and experiment” (KD5081) at Northumbria University, UK. The resources have been developed by Dr Lucy Whalley. If you spot any mistakes or have any suggestions please raise an issue on the Github repository for this course.\nThe website is powered by Github and fastpages, which is licensed under Apache License 2.0.\nThe content of this website is adapted and derived from several other sources:\n\nThe Setup instructions page is a derivative of materials from Software Carpentry, used under Attribution 4.0 International (CC BY 4.0).\nThe tutorial “Testing and Documentation” is a derivative of the Testing lesson from Code Refinery, used under Attribution 4.0 International (CC BY 4.0).\nSome of the exercises are adapted from the book Computational Physics. These are used with the permission of the book’s author, Mark Newman, and remain under his copyright.\n\nIn addition, parts of the “Getting results” section were inspired by Rudolf Winter’s notes on ODEs and PDEs.\nThe content of this website unless otherwise indicated is licensed under Creative Commons Attribution 4.0 International. You can re-use any of its content as long as an attribution is included, and you indicate if changes were made."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Physics",
    "section": "",
    "text": "Computing has become central to virtually all research and development in academia and industry, and with the advent of Machine Learning and High-Performance Computing this dominance is set to continue.\nComputational physics encompasses a wide number of areas including materials modelling, particle physics simulations, protein structure prediction and plasma modelling. In fact, it is possible to find a computational branch for every major field in physics.\nThe focus of this course is to equip with you with knowledge and skills needed to model a range of physical systems using numerical methods. You will also gain a number of transferable skills which can be applied across in a range of computational disciplines.\nThis course is split into three sections - Getting started, Getting results and Getting it out there. In the first part of the course, Getting started, we will recap the basic programming concepts and Python libraries that are applicable to a wide range of research and industry. In the middle section of the course, which is called Getting results, we will combine our Python knowledge with mathematical numerical methods to model various physical systems using differential equations. In the final unassessed section of the course, Getting it out there, we will use modern software engineering techniques to document, test and share our code.\n\nHow does this course relate to experimental physics?\nThe first part of this course recaps the basic skills needed for processing experimental data using Python. At the end of Getting started you will be able to read in experimental data from a plain text file, clean the data, apply basic statistical analysis and plot. We very much encourage you to apply the tools outlined in this course to your experimental analysis.\n\n\nDo I need to attend the in-person labs?\nWe will aim to publish all course materials on this website however a large component of this course is based on the verbal explanations whilst writing code (a.k.a, “live coding”) and class discussion. It will all make much more sense if you attend the sessions in the computer lab. The computer labs will not be recorded.\n\n\nWhy do you use a website?\nBlackboard collaborate is widely used at Northumbria University for teaching. However in the computational sciences (and in software engineering) Blackboard collaborate is not widely used. The aim here is to teach and learn using the tools that are already used in research and industry - hence building the course resources around the Github service. Also, the code can be nicely formatted using Markdown/html (rather than blackboard), making it easier for students to read and understand.\nThe source code for this website can be found in the course Github repository. If you spot any mistakes or would like to make a suggestions for improving the course please raise an issue on Github.\nBlackboard collaborate will be used for posting assessments and for course announcements."
  },
  {
    "objectID": "tutorials/integration.html",
    "href": "tutorials/integration.html",
    "title": "Riemann sums",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I do basic numerical integration?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nUse the rectangular-slice approximation to calculate integrals\nDescribe the difference between a zeroth-order and first-order integration rule\n\n\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nThe integral of \\(f(x)\\) from \\(a\\) to \\(b\\) is the area under the curve. Depending on the functional form of \\(f(x)\\), it may not be possible to calculate the integral analytically.\n\n\n\n\n\nRiemann sums are a family of methods used for approximating integrals\nThe Riemann definition of the integral \\(I\\) is:\n\\[ I = \\lim_{n\\to\\infty} \\sum_{i=1}^N h f(x_i)\\]\nwhere the domain of integration has been split into \\(N\\) slices, each with width \\(h = \\frac{b-a}{N}\\). As we cannot in practice consider an infinite number of slices, this definition will give an approximation to the exact answer. By making \\(N\\) large are approximation will, in many cases, be reasonable.\n\n\nThe simplest Riemann sum is based on rectangular slices\nThe simplest way to use this approach is to calculate \\(f(x_i)\\) at some point on each slice and then calculate the area of the associated rectangle:\n\\[ A_i = hf(x_i)\\]\nThe integral is given by summing over all of the rectangles:\n\\[ \\int_a^b f(x_i) dx \\approx \\sum_{i=1}^N A_i \\]\n\n\n\n\n\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nFor example, we may want to calculate the integral of \\(\\sin(x)\\) from 0 to \\(\\frac{\\pi}{2}\\). This is an integral that can be evaluated analytically, so it doesn’t usually make sense to calculate numerically - however, in this case, we can use it to establish that our method is correct.\n\nimport math\n\ndef sin(x):\n    \n    return math.sin(x)\n\ndef rectangular_slice_integral(f_x, a, b, N):\n    \n    integral = 0\n    h = (b-a) / N   # h is the width of each slice\n    for i in range(N):\n        x = a + h*i # the x value for the slice\n        integral += f_x(x)*h\n    return integral\n\nNote that the function rectangular_slice_integral has an argument f_x which is itself a function. This is valid Python - you can pass one function to another function as an argument.\n\nrectangular_slice_integral(sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nIn fact, it is possible to pass the math.sin() function directly to rectangular_slice_integral():\n\nrectangular_slice_integral(math.sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nThis is pretty close to the correct value of 1. To improve our approximation we can increase the number of slices:\n\nrectangular_slice_integral(math.sin,0,math.pi/2,200)\n\n0.9960678687587687\n\n\n The Riemann sums method a zeroth-order integration rule that will integrate a zeroth-order polynomial (ie, constant number) exactly. It has an error of order \\(h\\) (\\(\\mathcal{O}(h)\\)) - when we halve the rectangular width, we halve the error. \n\n\nRiemann sums can be adapted for use with discrete data\nNot all integrations are integrations of functions. For example, we may want to integrate experimental data, in which case there is no function to call to find the value of f(x). Instead, the most likely form of f(x) is given by the list of data values. In this case we can use the same method, but the implementation is slightly different:\n\ndef rectangular_slice_integral_discrete(data, h):\n    \n    return h*sum(data)\n\n Note that this assumes the data is evenly spaced at width \\(h\\) .\nTo test our function using the same example as above we need to generate a list of sin(x) values between 0 to \\(\\frac{\\pi}{2}\\):\n\nimport numpy as np\n\nh = (math.pi/2)/100\nsin_0_90 = [math.sin(x) for x in np.arange(0,math.pi/2,h)]\n\nwhere we are using Python list comprehension and the Numpy arange function to generate a list of evenly spaced floats.\nIf we are simulating experimental data we should add a little noise or randomness to the data. We can use the Python standard library random and list comprehension to do this:\n\nimport random\n\nsin_0_90_noise = [x+random.uniform(-0.1,0.1) for x in sin_0_90]\n\nWe can now pass this list to our function rectangular_slice_integral_discrete:\n\nrectangular_slice_integral_discrete(sin_0_90_noise, h)\n\n1.0094729791206596\n\n\nWe can visualise the exact sinusoidal curve and noisy sinusoidal curve using the matplotlib plotting library:\n\nimport matplotlib.pyplot as plt\n\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90,label=\"exact sine\")\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90_noise,label=\"noisy sine\")\n\n\n\n\n\n\nHigher-order Riemann sums increase the accuracy of our approximations\nWe can greatly improve the efficiency of our integration by approximating the slices as trapezoids instead of as rectangles. This is because the area under the trapezoids is a considerably better approximation to the area under the curve.\n The trapezoidal rule a first-order integration rule that will integrate a first-order polynomial (ie, a straight line) exactly. We can say it is accurate to order \\(h\\) (\\(\\mathcal{O}(h)\\)) and has an error of order \\(h^2\\) \\(\\mathcal{O}(h^2)\\) .\n\n\n\nIn many cases we can use Simpson’s Rule for greater accuracy still. This technique involves fitting quadratic curves to pairs of slices and then calculating the area under the quadratics. In many cases Simpson’s rule is more accurate than the trapezoidal rule, but this is not guaranteed for all integrands.\n\n\n\n\n\n\nKeypoints\n\n\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nRiemann sums are a family of methods used for approximating integral\nThe simplest Riemann sum is based on rectangular slices\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nRiemann sums can be adapted for use with discrete data\nHigher-order Riemann sums increase the accuracy of our approximations\n\n\n\n\n\n\n\n\n\nTest your understanding\n\n\n\n\nQuick test questions\nExtended questions"
  },
  {
    "objectID": "notebooks/integration.html",
    "href": "notebooks/integration.html",
    "title": "Riemann sums",
    "section": "",
    "text": "Questions\n\n\n\n\nHow can I do basic numerical integration?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nUse the rectangular-slice approximation to calculate integrals\nDescribe the difference between a zeroth-order and first-order integration rule\n\n\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nThe integral of \\(f(x)\\) from \\(a\\) to \\(b\\) is the area under the curve. Depending on the functional form of \\(f(x)\\), it may not be possible to calculate the integral analytically.\n\n\n\n\n\nRiemann sums are a family of methods used for approximating integrals\nThe Riemann definition of the integral \\(I\\) is:\n\\[ I = \\lim_{n\\to\\infty} \\sum_{i=1}^N h f(x_i)\\]\nwhere the domain of integration has been split into \\(N\\) slices, each with width \\(h = \\frac{b-a}{N}\\). As we cannot in practice consider an infinite number of slices, this definition will give an approximation to the exact answer. By making \\(N\\) large are approximation will, in many cases, be reasonable.\n\n\nThe simplest Riemann sum is based on rectangular slices\nThe simplest way to use this approach is to calculate \\(f(x_i)\\) at some point on each slice and then calculate the area of the associated rectangle:\n\\[ A_i = hf(x_i)\\]\nThe integral is given by summing over all of the rectangles:\n\\[ \\int_a^b f(x_i) dx \\approx \\sum_{i=1}^N A_i \\]\n\n\n\n\n\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nFor example, we may want to calculate the integral of \\(\\sin(x)\\) from 0 to \\(\\frac{\\pi}{2}\\). This is an integral that can be evaluated analytically, so it doesn’t usually make sense to calculate numerically - however, in this case, we can use it to establish that our method is correct.\n\nimport math\n\ndef sin(x):\n    \n    return math.sin(x)\n\ndef rectangular_slice_integral(f_x, a, b, N):\n    \n    integral = 0\n    h = (b-a) / N   # h is the width of each slice\n    for i in range(N):\n        x = a + h*i # the x value for the slice\n        integral += f_x(x)*h\n    return integral\n\nNote that the function rectangular_slice_integral has an argument f_x which is itself a function. This is valid Python - you can pass one function to another function as an argument.\n\nrectangular_slice_integral(sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nIn fact, it is possible to pass the math.sin() function directly to rectangular_slice_integral():\n\nrectangular_slice_integral(math.sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nThis is pretty close to the correct value of 1. To improve our approximation we can increase the number of slices:\n\nrectangular_slice_integral(math.sin,0,math.pi/2,200)\n\n0.9960678687587687\n\n\n The Riemann sums method a zeroth-order integration rule that will integrate a zeroth-order polynomial (ie, constant number) exactly. It has an error of order \\(h\\) (\\(\\mathcal{O}(h)\\)) - when we halve the rectangular width, we halve the error. \n\n\nRiemann sums can be adapted for use with discrete data\nNot all integrations are integrations of functions. For example, we may want to integrate experimental data, in which case there is no function to call to find the value of f(x). Instead, the most likely form of f(x) is given by the list of data values. In this case we can use the same method, but the implementation is slightly different:\n\ndef rectangular_slice_integral_discrete(data, h):\n    \n    return h*sum(data)\n\n Note that this assumes the data is evenly spaced at width \\(h\\) .\nTo test our function using the same example as above we need to generate a list of sin(x) values between 0 to \\(\\frac{\\pi}{2}\\):\n\nimport numpy as np\n\nh = (math.pi/2)/100\nsin_0_90 = [math.sin(x) for x in np.arange(0,math.pi/2,h)]\n\nwhere we are using Python list comprehension and the Numpy arange function to generate a list of evenly spaced floats.\nIf we are simulating experimental data we should add a little noise or randomness to the data. We can use the Python standard library random and list comprehension to do this:\n\nimport random\n\nsin_0_90_noise = [x+random.uniform(-0.1,0.1) for x in sin_0_90]\n\nWe can now pass this list to our function rectangular_slice_integral_discrete:\n\nrectangular_slice_integral_discrete(sin_0_90_noise, h)\n\n1.0094729791206596\n\n\nWe can visualise the exact sinusoidal curve and noisy sinusoidal curve using the matplotlib plotting library:\n\nimport matplotlib.pyplot as plt\n\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90,label=\"exact sine\")\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90_noise,label=\"noisy sine\")\n\n\n\n\n\n\nHigher-order Riemann sums increase the accuracy of our approximations\nWe can greatly improve the efficiency of our integration by approximating the slices as trapezoids instead of as rectangles. This is because the area under the trapezoids is a considerably better approximation to the area under the curve.\n The trapezoidal rule a first-order integration rule that will integrate a first-order polynomial (ie, a straight line) exactly. We can say it is accurate to order \\(h\\) (\\(\\mathcal{O}(h)\\)) and has an error of order \\(h^2\\) \\(\\mathcal{O}(h^2)\\) .\n\n\n\nIn many cases we can use Simpson’s Rule for greater accuracy still. This technique involves fitting quadratic curves to pairs of slices and then calculating the area under the quadratics. In many cases Simpson’s rule is more accurate than the trapezoidal rule, but this is not guaranteed for all integrands.\n\n\n\n\n\n\nKeypoints\n\n\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nRiemann sums are a family of methods used for approximating integral\nThe simplest Riemann sum is based on rectangular slices\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nRiemann sums can be adapted for use with discrete data\nHigher-order Riemann sums increase the accuracy of our approximations\n\n\n\n\n\nTest your understanding\n\n\n\n\n\n\nIntegrating a semicircle\n\n\n\n\n\n\nUse Riemann sums (with 10 rectangular slices) to calculate the value of the integral:\n\n\\[ I = \\int_{-1}^1\\sqrt{1-x^2}\\mathrm{d}x \\]\n\nHow does this compare to exact answer? (Hint: the integrand is a semicircle of radius 1)\nHow can you improve the accuracy of your estimate?\n\n\n\n\n\n\n\nShow answer\n\n\n\n\n\n\nWe can use the same approach as in the tutorial, but with a different function for calculating the integrand.\n\nimport math\n\ndef semicircle(x):\n    \n    return math.sqrt(1-x**2)\n\ndef rectangular_slice_integral(f_x, a, b, N):\n    \n    integral = 0\n    h = (b-a) / N   # h is the width of each slice\n    for i in range(N):\n        x = a + h*i # the x value for the slice\n        integral += f_x(x)*h\n    return integral\n    \nrectangular_slice_integral(semicircle, -1, 1, 100)\n1.5691342555492505\n\nThe exact answer is \\(\\frac{\\pi}{2}\\). The error on our calculation is\n\nmath.pi/2 - rectangular_slice_integral(semicircle, -1, 1, 100)\n0.0016620712456461018\n\nTo improve the accuracy we can use a larger number of slices:\n\nmath.pi/2 - rectangular_slice_integral(semicircle, -1, 1, 1000)\n5.2588293825595045e-05"
  },
  {
    "objectID": "markdown/recap.html",
    "href": "markdown/recap.html",
    "title": "Python recap",
    "section": "",
    "text": "A pre-requisite for this course is a basic understanding of Python. If you need to recap on the basics, you can use the Python for Physicists website - this covers all of the pre-requisite knowledge needed.\nTo self-assess your level of understanding, we recommend using ChooChoo the Checklist tool."
  },
  {
    "objectID": "markdown/quality.html",
    "href": "markdown/quality.html",
    "title": "Code Quality",
    "section": "",
    "text": "1. Document your code\nThere are multiple ways you can document your code. Below are three examples:\n\nDocstrings\nDocstrings are the first statement in a module, function, class or method so programmers can understand what it does without having to read the details of the implementation.\nDocstrings are string literals so must be contained within single quote marks (for single line docstrings) or triple quotes (for multiline docstrings). See the example below for a function-level docstring.\n def calc_bulk_density(mass,volume):\n     \"Return dry bulk density = powder mass / powder volume.\"\n     return mass / volume\nDocstrings are preferred over in-line comments (see below) as the docstrings can be easily accessed using the Python help() function. It is also possible to generate online documentation automatically from docstrings.\n\n\nIn-line comments\n# bulk density is the powder mass / powder volume\ndensity = mass / volume \n\n\nMarkdown in a Jupyter Notebook\nFor more extensive discussion you can combine code and text in a single document. See this tutorial for more information about using Markdown in a Jupyter Notebook.\n\n\n\n2. Focus on readability\nYour code should be easily readable by others. This is a big topic! The Pep 8 Style Guide for Python code has further guidance, although it is a daunting document. The most important thing is that you are consistent within your own code.\n\nConsistency is key\nCode formatting (for example, brackets) and use of whitespace should be consistent. For example, do not mix-and-match whitespace as in the code below:\nspam(ham[1], {eggs: 2})   \nspam( ham[ 1 ], { eggs: 2} )\nYou should also avoid mixing data types where possible. For example, using a 2-dimensional Numpy array and a 1-dimensional Numpy array within a simulation would usually be better than using a 2-dimensional Numpy array and a 1-dimensional Python list.\n\n\nVariable and function names\nUse clear, meaningful variable and function names - don’t just use x, p and expect the reader to know what they mean! For example angular_momentum is a better variable name than omega.\n\n\nClear code structure\nImport all of the libraries used at the top of your code. Also define any constants that will not change during your simulation (for example, the radius of the earth) at the top of your code.\nUse Markdown to write section headings in a Jupyter Notebook. You can also use blank lines to split code into logical blocks. Split long lines of your code using a \\ at the end of the line(s). For example:\nprint(\"this is a really really long line of code \\\nthat I'd like split over two lines\")\n\n\n\n3. Avoid duplication\nDuplication of code should be avoided where possible. There are several ways this can be achieved.\n\nWrite functions\nIf you will re-use a block of code multiple times consider encapsulating it in a function. See this tutorial for information about writing functions.\n\n\nUse external libraries\nUse appropriate functions and data-types, including those from external libraries. For example, if you need to perform mathematical operations on an array of values, use Numpy arrays instead of Python lists.\n\n\nUse control structures when appropriate\nUse control structures appropriately. Only use if, while or for loops when necessary.\n\n\n\n4. Think about reproducibility\nWriting reproducible code is difficult. In fact, there are many interesting initiatives designed to improve reproducibility in the computational scientists, such as Reprohacks.\nOne straight-forward thing you can do is print the version number for each package you import using print(packagename.__version__)"
  },
  {
    "objectID": "markdown/recap_questions.html",
    "href": "markdown/recap_questions.html",
    "title": "Questions",
    "section": "",
    "text": "Altitude of a satellite\nA satellite is launched into a circular orbit around the earth so that it orbits the planet once every \\(T\\) seconds. The altitude \\(h\\) above the Earth’s surface that the satellite must have is:\n\\(h = \\left(\\frac{GMT^2}{4\\pi^2}\\right)^{\\frac{1}{3}} - R\\)\nwhere \\(G\\) is Newton’s gravitational constant, \\(M\\) is the mass of the Earth, and \\(R\\) is the radius.\n\nWrite a piece of code which calculates the altitude \\(h\\) (in metres) for a given value of \\(T\\) (in seconds).\nUse this code to calculate the altitude of satellites that orbit the Earth once a day (a “geosynchronous” orbit) and once every 45 minutes. What can you conclude from this final calculation?\n\n\n\nThe emission lines of hydrogen\n\nThere is a simple and famous formula for calculating the wavelengths \\(\\lambda\\) of the emission lines of the hydrogen atom.\n\\(\\frac{1}{\\lambda} = R\\left(\\frac{1}{m^2} - \\frac{1}{n^2}\\right)\\)\nwhere R is the Rydberg constant \\(R = 1.097\\times 10^{-2}\\mathrm{nm}^{-1}\\) and \\(m\\) and \\(n\\) are positive integers and \\(n&gt;m\\).\n\nWrite a piece of code to calculate the first five transitions in the Lyman series (\\(m=1\\), transitions to the ground state, emission in the UV-range), Balmer series (\\(m=2\\), transitions to the first excited state, emissions in the visible region) and Paschen series (\\(m=3\\), emissions in the infra-red).\n\n\n\nCalculating Planck’s constant\nWhen light is shone on the surface of a metal, the photons in the light can excite (transfer energy to) electrons in the metal and, sometimes, eject them from the surface into the free space above. The energy of the ejected electron can be calculated by measuring the minimum voltage \\(V\\) that stops the electron moving.\nWe know that the energy of an ejected electron is equal to the energy of the photon that excited it minus the workfunction \\(\\phi\\) (which is the energy needed to remove it from the surface) and that the energy of a single photon is \\(hf\\) where \\(h\\) is Planck’s constant and \\(f\\) is the frequency of light. Mathematically this can be expressed as:\n\\(eV = hf - \\phi\\),\nwhere \\(e\\) is the charge of the electron.\n\nRead in the photoelectric measurement data from the file Planck.txt. The first column contains frequencies \\(f\\) is hertz and the second column contains voltages \\(V\\). Use this data to plot \\(V\\) vs \\(f\\). Think about the plot type - does a scatter plot of line plot make most sense?\n\nThe least-squares method is very commonly used for fitting a polynomial to a set of data. As it is so prevalent in physics and engineering, you are encouraged to watch this video which give an intuitive and mathematical description of the method.\n\nFit a straight line (polynomial of degree one) to the data using the least-squares method implemented in numpy.polyfit. Overlay this line on your data points.\nUsing the gradient of the fitted line calculate a value for Planck’s constant. Compare this to values you can find online.\n\n\n\nThe Madelung constant\nThe Madelung constant gives the total electric potential felt by an atom in a solid. It depends on the charge and position of other nearby atoms.\nConsider the compound sodium chloride. These are arranged on a cubic lattice, with sodium having a positive charge (\\(+e\\)) and chlorine having a negative charge (\\(-e\\)). If each atom position is given by integers \\((i,j,k)\\) then the sodium atoms are at positions where \\(i+j+k\\) is even and the chlorine atoms are at positions where \\(i+j+k\\) is odd.\n\nFor an atom at \\(i=j=k=0\\), the Madelung constant \\(M\\) can be approximated by using the following formulae:\n\\(V_\\mathrm{total} = \\sum_{i,j,k} V(i,j,k) = \\frac{e}{4\\pi\\epsilon_0a}M\\)\n\\(V(i,j,k) = \\pm\\\\frac{e}{4\\pi\\epsilon_0r}\\)\nwhere \\(r\\) is the distance from the origin to the atom at position \\((i,j,k)\\) and \\(a\\) is the atom spacing. The summation runs from \\(i,j,k=-L\\) to \\(i,j,k=L\\) but not including \\(i,j,k=0\\) (otherwise the expression would “blow up”).\n\nWrite an expression (in Markdown/LaTeX) for the distance \\(r\\) in terms of \\(i\\), \\(j\\), \\(k\\) and \\(a\\).\nCalculate the Madelung constant for sodium chloride using a large a value as L as you can (so the code runs in about a minute or less). How does it compare with published values?"
  },
  {
    "objectID": "notebooks/integration.html#questions",
    "href": "notebooks/integration.html#questions",
    "title": "Riemann sums",
    "section": "",
    "text": "How can I do basic numerical integration?"
  },
  {
    "objectID": "notebooks/integration.html#test-your-understanding",
    "href": "notebooks/integration.html#test-your-understanding",
    "title": "Riemann sums",
    "section": "Test your understanding",
    "text": "Test your understanding\n\n\n\n\n\n\nIntegrating a semicircle\n\n\n\n\n\nUse Riemann sums (with 10 rectangular slices) to calculate the value of the integral:\n\\[ I = \\int_{-1}^1\\sqrt{1-x^2}\\mathrm{d}x \\]\nHow does this compare to exact answer? (Hint: the integrand is a semicircle of radius 1)\nHow can you improve the accuracy of your estimate?\n\n\n\n\n\n\nShow answer\n\n\n\n\n\nWe can use the same approach as in the tutorial, but with a different function for calculating the integrand.\nimport math\n\ndef semicircle(x):\n    \n    return math.sqrt(1-x**2)\n\ndef rectangular_slice_integral(f_x, a, b, N):\n    \n    integral = 0\n    h = (b-a) / N   # h is the width of each slice\n    for i in range(N):\n        x = a + h*i # the x value for the slice\n        integral += f_x(x)*h\n    return integral\n    \nrectangular_slice_integral(semicircle, -1, 1, 100)\n1.5691342555492505\nThe exact answer is \\(\\frac{\\pi}{2}\\). The error on our calculation is\nmath.pi/2 - rectangular_slice_integral(semicircle, -1, 1, 100)\n0.0016620712456461018\nTo improve the accuracy we can use a larger number of slices:\nmath.pi/2 - rectangular_slice_integral(semicircle, -1, 1, 1000)\n5.2588293825595045e-05"
  },
  {
    "objectID": "notebooks/monte_carlo.html",
    "href": "notebooks/monte_carlo.html",
    "title": "Monte Carlo",
    "section": "",
    "text": "Questions\n\n\n\n\nHow do I generate random numbers?\nHow do I integrate using Monte Carlo methods?\nWhen might Monte Carlo integration be useful?\n\n\n\n\n\n\n\n\n\nObjectives\n\n\n\n\nUse the random module to generate random numbers\nUse Monte Carlo methods to calculate the area of a circle\n\n\n\n\nThere are many different numerical methods for calculating integrals\nIn the previous section we studied the simplest methods for calculating integrals: the rectangular-slice method . For increased accuracy and computational efficiency, there are extensions to this approach - for example, the trapezoid method (where each slice is a trapezoid rather than rectangle) or Simpson’s rule (where a quadratic curve is fitted to each slice). For certain classes of functions we can increase the performance further using more specialised approaches such as Gaussian Quadrature.\nOne particularly flexible and general purpose approach for calculating integrals is to use Monte Carlo integration. This approach is useful when the integrand is “pathological” (wildly varying) or noisy, or when the integration is performed over several variables.\n\n\nMonte Carlo methods calculate the answers to exact calculations by doing random calculations\nMonte Carlo methods are a broad class of algorithms that rely on random sampling to obtain numerical results. The underlying concept is to use randomness to solve problems that might be deterministic in principle. “Monte Carlo” is a reference to a well-known casino town, since the element of chance is core to the modelling approach, similar to various casino games.\nMonte Carlo methods are applied across a wide variety of domains, most commonly mathematics, physics and finance. In physics, Monte Carlo methods are used to design particle detectors, model galaxy evolution and solve the many-body problem for quantum systems, amongst many other applications. In this lesson we will introduce one of the main uses of Monte Carlo: for integration.\n\n\nThe Monte Carlo “area method” estimates integrals by generating a uniform sample of points and counting how many fall into a planar region\nConsider the shaded area as shown below. This is the integral \\(I\\) which we wish to calculate.\n\nIf we choose a point uniformly at random in the rectange (dashed red line) that bounds the shaded area, the probability \\(p\\) that the point falls in the shaded area is\n\\[p = \\frac{I}{A}\\]\nwhere \\(A\\) is the area of the bounding rectangle. This means that the integral \\(I\\) can be calculated if we know the area of the bounding rectangle and the probability \\(p\\):\n\\[I = Ap\\]\nTo calculate \\(p\\) we can randomly generate \\(N\\) points in the bounding area and keep count as to how many lie in the shaded area. If \\(k\\) lie in the shaded area then the fraction of points \\(\\frac{k}{N}\\) should be equal to the probability \\(p\\).\n\\[I = \\frac{Ak}{N}\\]\nWe can extend this approach to higher dimensions to consider integrands lying within a bounding volume, or higher dimensional space (which is considered in the extension exercise for this lesson).\n\n\nWe can use the Monte Carlo area method to estimate pi\nWe’ll now use this approach to give us an estimate for the value of pi by considering the area under a quarter-circle.\n\n\n\nThe relevant equations are:\nsquare area: \\(A_s = (2 r)^2\\)\ncircle area: \\(A_c = \\pi r^2\\)\nThe ratio of the areas can be related to \\(\\pi\\) through the following expressions:\n\\[\\frac{A_c}{A_s} = \\frac{\\pi r^2}{4 r^2} = \\frac{\\pi}{4}\\]\n\\[\\pi = 4\\frac{A_c}{A_s}\\]\nTo approximate the ratio \\(\\frac{A_c}{A_s}\\) we will generate a (uniform) pseudo-random number between 0 and 1 for our x-coordinates, and a (uniform) pseudo-random number between 0 and 1 for our y-coordinates. We will then check if our random point lies in or out of the circle. The probability \\(P_i\\) that our point lies in the circle is related to the area ratio and so value of pi:\n\\[P_i = \\frac{A_c}{A_s} = \\frac{\\pi}{4}\\]\n\n\nThe Monte Carlo area method can be translated into Python code\n\n# importing the modules we will need\nimport random\nimport math\n\n# in this function we generate random numbers and count how many lie within the circle\ndef estimate_pi(num_points):\n    \n    points = []\n    hits = 0\n    for i in range(num_points):\n        # random.random returns a random number drawn from a uniform distribution from 0 to 1\n        x, y = random.random(), random.random()\n        # we test if the point is within the circle (using the equation for a circle, X^2+y^2=r^2)\n        if x*x + y*y &lt; 1.0:\n            hits += 1\n    \n    probability = hits / num_points\n    return probability*4\n        \n\n\nestimate_pi(1000)\n\n3.104\n\n\n\nestimate_pi(2000)\n\n3.176\n\n\nThis method usually improves with the number of points, however there can be some variation due to the randomness of the numbers used. If you would like others to reproduce your exact results, you can seed the (pseudo-)random number generator:\n\nrandom.seed(1)\nprint(\"error is {}\".format(math.pi-estimate_pi(1000)))\n\nerror is 0.029592653589793017\n\n\n\nrandom.seed(1)\nprint(\"error is {}\".format(math.pi-estimate_pi(2000)))\n\nerror is -0.004407346410206792\n\n\n\n\nMonte Carlo integration is computationally efficient for particular types of integrand\nThe error when using Monte Carlo integration is proportional to \\(N^{-\\frac{1}{2}}\\), which is larger than the rectangular slice approach with error order \\(h \\propto N^{-1}\\) (where \\(N\\) in this case is the number of integration slices). However Monte Carlo methods are more flexible and can be used where other methods break-down: for example, they are particularly useful for integrating functions where the integrand varies very quickly, and/or where the integral is over many variables. In many cases, for “well behaved” functions, an approach based on Riemann summation will give more accurate and computationally efficient results.\n\n\n\n\n\n\nKeypoints\n\n\n\n\nThere are many different numerical methods for calculating integrals\nMonte Carlo methods calculate the answers to exact calculations by doing random calculations\nThe Monte Carlo “area method” estimates integrals by generating a uniform sample of points and counting how many fall into a planar region\nWe can use the Monte Carlo area method to estimate pi\nThe Monte Carlo area method can be translated into Python code\nMonte Carlo integration is computationally efficient for particular types of integrand\n\n\n\n\n\nTest your understanding\n\n\n\n\n\n\nIntegrating a semicircle re-visited\n\n\n\n\n\n\nUse Monte Carlo integration (with 100 random points) to calculate the value of the integral:\n\n\\[ I = \\int_{-1}^1\\sqrt{1-x^2}\\mathrm{d}x \\]\n\nHow does this compare to exact answer? (Hint: the integrand is a semicircle of radius 1)\nHow can you improve the accuracy of your estimate?\nIncrease the number of points until you get an accuracy comparable (same order of magnitude) as the Riemann sum method with 100 points.\nUse the %%timeit notebook magic to compare the calculation times for the Riemann sum method and Monte Carlo method. Which is more efficient?\n\n\n\n\n\n\n\nShow answer\n\n\n\n\n\n\nWe want to calculate the area of a semicircle with radius 1. We can adapt the approach used in the Monte Carlo tutorial but, in this case, we use the fact that \\(P_i = \\frac{A_c}{A_r}\\) where \\(A_r\\) is a rectangle of length 2 (as the semicircle goes from \\(-1\\) to \\(1\\)) and height 1.\n\nimport random\nimport math\n    \ndef estimate_semicircle_area(num_points):\n    \n    points = []\n    hits = 0\n    for i in range(num_points):\n        # random.uniform(a,b) returns a random number drawn from a uniform distribution from a to b\n        x, y = random.uniform(-1,1), random.uniform(0,1)\n        # we test if the point is within the circle (using the equation for a circle, X^2+y^2=r^2)\n        if x*x + y*y &lt; 1.0:\n            hits += 1\n    \n    probability = hits / num_points\n    rectangle_area = 2\n    return probability*rectangle_area\n    \nestimate_semicircle_area(100)\n1.58\nNote that your estimate will be different as you be using a different set of random numbers.\n\nThe exact answer is \\(\\frac{\\pi}{2}\\). The error on our calculation is\n\nmath.pi/2 - estimate_semicircle_area(100)\n-0.04920367320510355\n\nTo improve the accuracy we can use a larger number of random points:\n\nmath.pi/2 - estimate_semicircle_area(1000)\n0.04679632679489654\nmath.pi/2 - estimate_semicircle_area(10000)\n-0.0048036732051033315\n\nIncreasing the number of points to 10,000 gives an error comparable to the Riemann sum method with 100 integration slices (where the error is 0.002).\nLet’s use the %%timeit magic to time how long each takes to run\n\n%%timeit\nestimate_semicircle_area(10000)\n6.23 ms ± 370 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n%%timeit\nrectangular_slice_integral(semicircle, -1, 1, 100)\n31 µs ± 1.09 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\nAs each method gives roughly the same accuracy, but the estimate_semicircle_area is 100x smaller, we can deduce that the Monte Carlo method implemented in estimate_semicircle_area is considerably less efficient than the Riemann summation method implemented in rectangular_slice_integral. However the Monte Carlo method is useful for badly behaving systems, as we will see in the lesson exercises."
  },
  {
    "objectID": "markdown/integration_questions.html",
    "href": "markdown/integration_questions.html",
    "title": "Integration questions",
    "section": "",
    "text": "Planck’s law tells us that in the angular frequency interval \\(\\omega\\) to \\(\\omega+\\mathrm{d}\\omega\\), a black-body of unit area and temperature \\(T\\) radiates electromagnetically an amount of thermal energy per second equal to \\(I(\\omega)\\mathrm{d}\\omega\\), where\n\\[I(\\omega) = \\frac{\\hbar}{4\\pi^2\\mathrm{c}^2}\\frac{\\omega}{(\\mathrm{e}^{\\frac{\\hbar\\omega}{k_\\mathrm{B}T}}-1)}.\\]\nThe quantum theory of modern physics was born with Planck’s law. Up until this point, an outstanding problem in physics was the ultra-violet catastrophe, a prediction from classical physics that a black body at thermal equilibrium would emit an unbounded quantity of energy as wavelength decreased into the ultraviolet range. This was in stark contrast to what was being measured experimentally. To resolve this, Planck assumed that electromagnetic radiation can only be absorbed or emitted in discrete packets (quanta) and from this derives Planck’s law as shown above. Planck’s law was in agreement with experimental results and the Stefan-Boltzmann law, which states:\n\\[W = \\sigma T^4\\]\nwhere \\(\\sigma\\) is the Stefan-Boltzmann constant.\nEinstein later postulated that the discrete quanta are real, physical particles (photons) and used this to explain the photoelectric effect. This research resulted in Einstein receiving the Nobel prize for physics in 1921.\nBy substituting \\(x = \\frac{\\hbar\\omega}{k_\\mathrm{B}T}\\) we can deduce that the total rate of energy radiation by a black body per unit area, over all frequencies, is\n\\[W = \\frac{k_\\mathrm{B}^4T^4}{4\\pi^2\\mathrm{c}^2\\hbar^3}\\int_0^\\infty\\frac{x^3}{(\\mathrm{e}^x-1)}\\mathrm{d}x.\\]\n\nWe will approximate the exact expression, an integral from 0 to \\(\\infty\\), using an integral with finite limits. Plot the integrand as a function of \\(x\\) to justify your choice of limits.\nUse the rectangular slice method to evaluate the integral in the expression for \\(W\\)\nUse your value for the integral above to compute a value for the Stefan-Boltzmann constant to three significant figures. Check your result against the known value (available in the scipy.constants library).\nShow that the error of your estimate scales linearly with the width \\(h\\) of the rectangular slices used to approximate the integral."
  },
  {
    "objectID": "markdown/integration_questions.html#the-stefan-boltzmann-constant",
    "href": "markdown/integration_questions.html#the-stefan-boltzmann-constant",
    "title": "Integration questions",
    "section": "",
    "text": "Planck’s law tells us that in the angular frequency interval \\(\\omega\\) to \\(\\omega+\\mathrm{d}\\omega\\), a black-body of unit area and temperature \\(T\\) radiates electromagnetically an amount of thermal energy per second equal to \\(I(\\omega)\\mathrm{d}\\omega\\), where\n\\[I(\\omega) = \\frac{\\hbar}{4\\pi^2\\mathrm{c}^2}\\frac{\\omega}{(\\mathrm{e}^{\\frac{\\hbar\\omega}{k_\\mathrm{B}T}}-1)}.\\]\nThe quantum theory of modern physics was born with Planck’s law. Up until this point, an outstanding problem in physics was the ultra-violet catastrophe, a prediction from classical physics that a black body at thermal equilibrium would emit an unbounded quantity of energy as wavelength decreased into the ultraviolet range. This was in stark contrast to what was being measured experimentally. To resolve this, Planck assumed that electromagnetic radiation can only be absorbed or emitted in discrete packets (quanta) and from this derives Planck’s law as shown above. Planck’s law was in agreement with experimental results and the Stefan-Boltzmann law, which states:\n\\[W = \\sigma T^4\\]\nwhere \\(\\sigma\\) is the Stefan-Boltzmann constant.\nEinstein later postulated that the discrete quanta are real, physical particles (photons) and used this to explain the photoelectric effect. This research resulted in Einstein receiving the Nobel prize for physics in 1921.\nBy substituting \\(x = \\frac{\\hbar\\omega}{k_\\mathrm{B}T}\\) we can deduce that the total rate of energy radiation by a black body per unit area, over all frequencies, is\n\\[W = \\frac{k_\\mathrm{B}^4T^4}{4\\pi^2\\mathrm{c}^2\\hbar^3}\\int_0^\\infty\\frac{x^3}{(\\mathrm{e}^x-1)}\\mathrm{d}x.\\]\n\nWe will approximate the exact expression, an integral from 0 to \\(\\infty\\), using an integral with finite limits. Plot the integrand as a function of \\(x\\) to justify your choice of limits.\nUse the rectangular slice method to evaluate the integral in the expression for \\(W\\)\nUse your value for the integral above to compute a value for the Stefan-Boltzmann constant to three significant figures. Check your result against the known value (available in the scipy.constants library).\nShow that the error of your estimate scales linearly with the width \\(h\\) of the rectangular slices used to approximate the integral."
  },
  {
    "objectID": "markdown/integration_questions.html#volume-of-a-sphere",
    "href": "markdown/integration_questions.html#volume-of-a-sphere",
    "title": "Integration questions",
    "section": "Volume of a sphere",
    "text": "Volume of a sphere\nWe have seen that performing an integral over one variable requires us to take samples across a one-dimensional grid. Similarly, integration over two variables requires us to take samples on a two-dimensional grid, and so on. The number of grid points required scales exponentially with the number of variables, so that integrals over three or more dimensions can quickly become unmanageable. In this case, Monte Carlo integration can be very useful.\nThe volume of a sphere with unit radius in three dimensions is given by:\n\\[V = \\int\\int\\int_{-1}^1f(x,y,z)\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z\\]\nwhere \\(f(x,y,z)=1\\) everywhere inside the sphere and zero everywhere outside.\n\nUse Monte Carlo integration to estimate the volume of this sphere using 100 random points.\nIncrease the number of random points until you reach an estimate that is exact to three significant figures.\nBy considering how many points would need to be sampled, estimate the length of time it would take to reach the same level of accuracy using a Riemann slice type method."
  },
  {
    "objectID": "markdown/integration_questions.html#the-stefan-boltzmann-constant-re-visited",
    "href": "markdown/integration_questions.html#the-stefan-boltzmann-constant-re-visited",
    "title": "Integration questions",
    "section": "The Stefan-Boltzmann constant re-visited",
    "text": "The Stefan-Boltzmann constant re-visited\nIn the Riemann sums tutorial question we use rectangular slices to estimate the Stefan-Boltzmann constant to three significant figures. The trapezoidal rule is a neat extension to rectangular slices, where the value at the start and end of each segment is considered. It can be expressed as\n\\[\\int^b_af(x)\\mathrm{d}x = h\\left[\\frac{1}{2}f(a)+\\frac{1}{2}f(b)+\\sum_{k=1}^{N-1}f(a+kh)\\right]\\]\n\nUse the trapezoidal rule to re-calculate the Stefan-Boltzmann constant to three significant figures\nDemonstrate that the error scales quadratically with \\(h^2\\), and that the trapezoidal rule is more computationally efficient than using rectangular slices\nThe error \\(\\epsilon_n\\) on the nth estimate of an integral is given by \\(\\epsilon_n = \\frac{1}{3}(I_n-I_{n-1})\\). Using this expression, write a programme that calculates the Stefan-Boltzmann with a maximum absolute error of 1E-5."
  },
  {
    "objectID": "markdown/integration_introduction.html",
    "href": "markdown/integration_introduction.html",
    "title": "Introduction to integration",
    "section": "",
    "text": "If one looks at the different problems of the integral calculus which arise naturally when one wishes to go deep into the different parts of physics, it is impossible not to be struck by the analogies existing. - Henri Poincaré\n\nOne of the most basic but also most important applications of computers in physics is the evaluation of integrals. Integrals occur widely in physics and, while some integrals can be done analytically, many cannot. In this lesson we will learn several methods for numerical integration and, as part of this, we will learn how to generate random numbers.\n\nBefore you begin\n\nCheck that Python and Jupyter Notebook are installed\nLaunch a Jupyter notebook\n\nPlease see the Setup page for more details.\n\n\nExternal resources\n\nTextbook: Mark Newman Computational Physics Chapters 5.1-5.4 and 10.2"
  },
  {
    "objectID": "markdown/integration_introduction.html#before-you-begin",
    "href": "markdown/integration_introduction.html#before-you-begin",
    "title": "Introduction to integration",
    "section": "Before you begin",
    "text": "Before you begin\n\nCheck that Python and Jupyter Notebook are installed\nLaunch a Jupyter notebook\n\nPlease see the Setup page for more details."
  },
  {
    "objectID": "markdown/integration_introduction.html#external-resources",
    "href": "markdown/integration_introduction.html#external-resources",
    "title": "Introduction to integration",
    "section": "External resources",
    "text": "External resources\n\nTextbook: Mark Newman Computational Physics Chapters 5.1-5.4 and 10.2"
  }
]