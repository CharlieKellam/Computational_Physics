[
  {
    "objectID": "integration.html",
    "href": "integration.html",
    "title": "Numerical Integration",
    "section": "",
    "text": "Questions:\n\nHow can I do basic numerical integration?\n\nObjectives:\n\nUse the rectangular-slice approximation to calculate integrals\nDescribe the difference between a zeroth-order and first-order integration rule\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nThe integral of \\(f(x)\\) from \\(a\\) to \\(b\\) is the area under the curve. Depending on the functional form of \\(f(x)\\), it may not be possible to calculate the integral analytically.\n\n\n\n\n\nRiemann sums are a family of methods used for approximating integral\nThe Riemann definition of the integral \\(I\\) is:\n$ I = {n} {i=1}^N h f(x_i)$\nwhere the domain of integration has been split into \\(N\\) slices, each with width \\(h = \\frac{b-a}{N}\\). As we cannot in practice consider an infinite number of slices, this definition will give an approximation to the exact answer. By making \\(N\\) large are approximation will, in many cases, be reasonable.\n\n\nThe simplest Riemann sum is based on rectangular slices\nThe simplest way to use this approach is to calculate \\(f(x_i)\\) at some point on each slice and then calculate the area of the associated rectangle:\n$ A_i = hf(x_i)$\nThe integral is given by summing over all of the rectangles:\n$ a^b f(x_i) dx {i=1}^N A_i $\n\n\n\n\n\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nFor example, we may want to calculate the integral of \\(\\sin(x)\\) from 0 to \\(\\frac{\\pi}{2}\\). This is an integral that can be evaluated analytically, so it doesn’t usually make sense to calculate numerically - however, in this case, we can use it to establish that our method is correct.\n\nimport math\n\ndef sin(x):\n    \n    return math.sin(x)\n\ndef rectangular_slice_integral(f_x, a, b, N):\n    \n    integral = 0\n    h = (b-a) / N   # h is the width of each slice\n    for i in range(N):\n        x = a + h*i # the x value for the slice\n        integral += f_x(x)*h\n    return integral\n\nNote that the function rectangular_slice_integral has an argument f_x which is itself a function. This is valid Python - you can pass one function to another function as an argument.\n\nrectangular_slice_integral(sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nIn fact, it is possible to pass the math.sin() function directly to rectangular_slice_integral():\n\nrectangular_slice_integral(math.sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nThis is pretty close to the correct value of 1. To improve our approximation we can increase the number of slices:\n\nrectangular_slice_integral(math.sin,0,math.pi/2,200)\n\n0.9960678687587687\n\n\n The Riemann sums method a zeroth-order integration rule that will integrate a zeroth-order polynomial (ie, constant number) exactly. It has an error of order \\(h\\) (\\(\\mathcal{O}(h)\\)) - when we halve the rectangular width, we halve the error. \n\n\nRiemann sums can be adapted for use with discrete data\nNot all integrations are integrations of functions. For example, we may want to integrate experimental data, in which case there is no function to call to find the value of f(x). Instead, the most likely form of f(x) is given by the list of data values. In this case we can use the same method, but the implementation is slightly different:\n\ndef rectangular_slice_integral_discrete(data, h):\n    \n    return h*sum(data)\n\n Note that this assumes the data is evenly spaced at width \\(h\\) .\nTo test our function using the same example as above we need to generate a list of sin(x) values between 0 to \\(\\frac{\\pi}{2}\\):\n\nimport numpy as np\n\nh = (math.pi/2)/100\nsin_0_90 = [math.sin(x) for x in np.arange(0,math.pi/2,h)]\n\nwhere we are using Python list comprehension and the Numpy arange function to generate a list of evenly spaced floats.\nIf we are simulating experimental data we should add a little noise or randomness to the data. We can use the Python standard library random and list comprehension to do this:\n\nimport random\n\nsin_0_90_noise = [x+random.uniform(-0.1,0.1) for x in sin_0_90]\n\nWe can now pass this list to our function rectangular_slice_integral_discrete:\n\nrectangular_slice_integral_discrete(sin_0_90_noise, h)\n\n1.0094729791206596\n\n\nWe can visualise the exact sinusoidal curve and noisy sinusoidal curve using the matplotlib plotting library:\n\nimport matplotlib.pyplot as plt\n\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90,label=\"exact sine\")\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90_noise,label=\"noisy sine\")\n\n\n\n\n\n\nHigher-order Riemann sums increase the accuracy of our approximations\nWe can greatly improve the efficiency of our integration by approximating the slices as trapezoids instead of as rectangles. This is because the area under the trapezoids is a considerably better approximation to the area under the curve.\n The trapezoidal rule a first-order integration rule that will integrate a first-order polynomial (ie, a straight line) exactly. We can say it is accurate to order \\(h\\) (\\(\\mathcal{O}(h)\\)) and has an error of order \\(h^2\\) \\(\\mathcal{O}(h^2)\\) .\n\n\n\nIn many cases we can use Simpson’s Rule for greater accuracy still. This technique involves fitting quadratic curves to pairs of slices and then calculating the area under the quadratics. In many cases Simpson’s rule is more accurate than the trapezoidal rule, but this is not guaranteed for all integrands.\n\nKeypoints:\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nRiemann sums are a family of methods used for approximating integral\nThe simplest Riemann sum is based on rectangular slices\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nRiemann sums can be adapted for use with discrete data\nHigher-order Riemann sums increase the accuracy of our approximations\n\n\nDo the quick-test.\nBack to Calculating Integrals."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational_Physics",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "tutorials/integration.html",
    "href": "tutorials/integration.html",
    "title": "Numerical Integration",
    "section": "",
    "text": "Questions:\n\nHow can I do basic numerical integration?\n\nObjectives:\n\nUse the rectangular-slice approximation to calculate integrals\nDescribe the difference between a zeroth-order and first-order integration rule\n\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nThe integral of \\(f(x)\\) from \\(a\\) to \\(b\\) is the area under the curve. Depending on the functional form of \\(f(x)\\), it may not be possible to calculate the integral analytically.\n\n\n\n\n\nRiemann sums are a family of methods used for approximating integral\nThe Riemann definition of the integral \\(I\\) is:\n$ I = {n} {i=1}^N h f(x_i)$\nwhere the domain of integration has been split into \\(N\\) slices, each with width \\(h = \\frac{b-a}{N}\\). As we cannot in practice consider an infinite number of slices, this definition will give an approximation to the exact answer. By making \\(N\\) large are approximation will, in many cases, be reasonable.\n\n\nThe simplest Riemann sum is based on rectangular slices\nThe simplest way to use this approach is to calculate \\(f(x_i)\\) at some point on each slice and then calculate the area of the associated rectangle:\n$ A_i = hf(x_i)$\nThe integral is given by summing over all of the rectangles:\n$ a^b f(x_i) dx {i=1}^N A_i $\n\n\n\n\n\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nFor example, we may want to calculate the integral of \\(\\sin(x)\\) from 0 to \\(\\frac{\\pi}{2}\\). This is an integral that can be evaluated analytically, so it doesn’t usually make sense to calculate numerically - however, in this case, we can use it to establish that our method is correct.\n\nimport math\n\ndef sin(x):\n    \n    return math.sin(x)\n\ndef rectangular_slice_integral(f_x, a, b, N):\n    \n    integral = 0\n    h = (b-a) / N   # h is the width of each slice\n    for i in range(N):\n        x = a + h*i # the x value for the slice\n        integral += f_x(x)*h\n    return integral\n\nNote that the function rectangular_slice_integral has an argument f_x which is itself a function. This is valid Python - you can pass one function to another function as an argument.\n\nrectangular_slice_integral(sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nIn fact, it is possible to pass the math.sin() function directly to rectangular_slice_integral():\n\nrectangular_slice_integral(math.sin,0,math.pi/2,100)\n\n0.9921254566056334\n\n\nThis is pretty close to the correct value of 1. To improve our approximation we can increase the number of slices:\n\nrectangular_slice_integral(math.sin,0,math.pi/2,200)\n\n0.9960678687587687\n\n\n The Riemann sums method a zeroth-order integration rule that will integrate a zeroth-order polynomial (ie, constant number) exactly. It has an error of order \\(h\\) (\\(\\mathcal{O}(h)\\)) - when we halve the rectangular width, we halve the error. \n\n\nRiemann sums can be adapted for use with discrete data\nNot all integrations are integrations of functions. For example, we may want to integrate experimental data, in which case there is no function to call to find the value of f(x). Instead, the most likely form of f(x) is given by the list of data values. In this case we can use the same method, but the implementation is slightly different:\n\ndef rectangular_slice_integral_discrete(data, h):\n    \n    return h*sum(data)\n\n Note that this assumes the data is evenly spaced at width \\(h\\) .\nTo test our function using the same example as above we need to generate a list of sin(x) values between 0 to \\(\\frac{\\pi}{2}\\):\n\nimport numpy as np\n\nh = (math.pi/2)/100\nsin_0_90 = [math.sin(x) for x in np.arange(0,math.pi/2,h)]\n\nwhere we are using Python list comprehension and the Numpy arange function to generate a list of evenly spaced floats.\nIf we are simulating experimental data we should add a little noise or randomness to the data. We can use the Python standard library random and list comprehension to do this:\n\nimport random\n\nsin_0_90_noise = [x+random.uniform(-0.1,0.1) for x in sin_0_90]\n\nWe can now pass this list to our function rectangular_slice_integral_discrete:\n\nrectangular_slice_integral_discrete(sin_0_90_noise, h)\n\n1.0094729791206596\n\n\nWe can visualise the exact sinusoidal curve and noisy sinusoidal curve using the matplotlib plotting library:\n\nimport matplotlib.pyplot as plt\n\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90,label=\"exact sine\")\nplt.plot(np.arange(0,math.pi/2,h),sin_0_90_noise,label=\"noisy sine\")\n\n\n\n\n\n\nHigher-order Riemann sums increase the accuracy of our approximations\nWe can greatly improve the efficiency of our integration by approximating the slices as trapezoids instead of as rectangles. This is because the area under the trapezoids is a considerably better approximation to the area under the curve.\n The trapezoidal rule a first-order integration rule that will integrate a first-order polynomial (ie, a straight line) exactly. We can say it is accurate to order \\(h\\) (\\(\\mathcal{O}(h)\\)) and has an error of order \\(h^2\\) \\(\\mathcal{O}(h^2)\\) .\n\n\n\nIn many cases we can use Simpson’s Rule for greater accuracy still. This technique involves fitting quadratic curves to pairs of slices and then calculating the area under the quadratics. In many cases Simpson’s rule is more accurate than the trapezoidal rule, but this is not guaranteed for all integrands.\n\nKeypoints:\n\nDepending on the functional form of f(x), it may not be possible to calculate an integral analytically\nRiemann sums are a family of methods used for approximating integral\nThe simplest Riemann sum is based on rectangular slices\nThe rectangular slices method can be translated to Python code in a straight-forward manner\nRiemann sums can be adapted for use with discrete data\nHigher-order Riemann sums increase the accuracy of our approximations\n\n\nDo the quick-test.\nBack to Calculating Integrals."
  }
]